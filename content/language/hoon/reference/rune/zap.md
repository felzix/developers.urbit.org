+++
title = "! zap · Wild"
weight = 110

[glossaryEntry.zap]
name = "zap"
symbol = "!"
usage = "wild"
desc = "Wildcard category. Expressions that don't fit anywhere else go here."

[glossaryEntry.zapgar]
name = "zapgar"
symbol = "!>"
usage = "wild"
slug = "#-zapgar"
desc = "<code>[%zpgr p=hoon]</code>: wrap a noun in its type."

[glossaryEntry.zapgal]
name = "zapgal"
symbol = "!<"
usage = "wild"
slug = "#-zapgal"
desc = "<code>[%zpld p=spec q=hoon]</code>: extracts typed value from a vase."

[glossaryEntry.zapcol]
name = "zapcol"
symbol = "!:"
usage = "wild"
slug = "#-zapcol"
desc = "<code>[%dbug p=hoon]</code>: turn on stack trace"

[glossaryEntry.zapdot]
name = "zapdot"
symbol = "!."
usage = "wild"
slug = "#-zapdot"
desc = "Turn off stack trace for a subexpression <code>p</code>"

[glossaryEntry.zaptis]
name = "zaptis"
symbol = "!="
usage = "wild"
slug = "#-zaptis"
desc = "<code>[%zpts p=hoon]</code>: make the Nock formula for a Hoon expression."

[glossaryEntry.zapwut]
name = "zapwut"
symbol = "!?"
usage = "wild"
slug = "#-zapwut"
desc = "<code>[%zpwt p=@ q=hoon]</code>: restrict Hoon version."

[glossaryEntry.zappat]
name = "zappat"
symbol = "!@"
usage = "wild"
slug = "#-zappat"
desc = "<code>[%zppt p=(list wing) q=hoon r=hoon]</code>: branch on wing existence."

[glossaryEntry.zapzap]
name = "zapzap"
symbol = "!!"
usage = "wild"
slug = "#-zapzap"
desc = "<code>[%zpzp ~]</code>: crash."

+++

## `!,` "zapcom"

Produce the Hoon AST of an expression.

#### Syntax

Two arguments, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !,  p
  q
  ```

---

- Wide
- ```hoon
  !,(p q)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpcm p=hoon q=hoon]
```

#### Discussion

This produces the [`$hoon`](/reference/hoon/stdlib/4o#hoon) AST of
expression `q`. The first argument, `p`, is always an example of the `$hoon`
type, typically just the `*hoon` bunt value, and is used for type inference. The
reason for `p` is just to handle transitions if the `$hoon` type changes.

#### Examples

```
> !,  *hoon  [1 1]
[%cltr p=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]

> !,  *hoon  (add 1 1)
[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
```

---

## `!>` "zapgar"

Wrap a noun in its type (form a [`vase`](/reference/hoon/stdlib/4o#vase)).

#### Syntax

One argument, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !>  p
  ```

---

- Wide
- ```hoon
  !>(p)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpgr p=hoon]
```

#### Produces

A cell whose tail is the product of `p`, and whose head is the static type of `p`.

#### Discussion

In Hoon, a dynamic type is a static type compiled at runtime. This type-noun
cell is generally called a [`vase`](/reference/hoon/stdlib/4o#vase).

#### Examples

```
> !>(1)
[#t/@ud q=1]
```

If you want just the type value, use a 'type spear'. This is `-:!>`, i.e., the
head of the cell produced by `!>`:

```
> -:!>(1)
#t/@ud
```

---

## `!<` "zapgal"

Extracts a [`vase`](/reference/hoon/stdlib/4o#vase) to the given mold if
its type nests.

#### Syntax

Two arguments, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !<  p
  q
  ```

---

- Wide
- ```hoon
  !<(p q)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpgl p=spec q=hoon]
```

#### Produces

The value of vase `q` typed with the type of mold `p` if possible, else a
`nest-fail`.

#### Discussion

This is something like a partial inverse to the `!>` rune and can be used to
extract a typed value from a `vase`.

#### Examples

```
> !<  @  !>  ~zod
0

> !<  @p  !>  0
nest-fail

> !<  tape  !>("foobar")
"foobar"
```

---

## `!;` "zapmic"

Wrap a noun in its type (raw).

#### Syntax

Two arguments, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !;  p
  q
  ```

---

- Wide
- ```hoon
  !;(p q)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpmc p=hoon q=hoon]
```

#### Discussion

This wraps the product of `q` in its inferred type. It's a raw version of
[`!>`](#-zapgar). Unlike zapgar, `q` is not given a `p` face and its type
information is not stripped to a raw noun.

The first field, `p`, must be an example of the
[`$type`](/reference/hoon/stdlib/4o#type) type, typically just `*type` (the
bunt of `$type`). The `p` argument is just so transitions can be handled if the
`$type` type changes.

It's unlikely you'd use this rune directly; [`!>`](#-zapgar) is much more
typical.

#### Examples

```
> !;  *type  [1 1]
[#t/[@ud @ud] 1 1]

> !;  *type  'foo'
[#t/@t 'foo']
```

---

## `!=` "zaptis"

Make the Nock formula for a Hoon expression.

#### Syntax

One argument, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !=  p
  ```

---

- Wide
- ```hoon
  !=(p)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpts p=hoon]
```

#### Produces

The Nock generated by `p`.

#### Discussion

Don't confuse `!=` with a negation, `!`, followed by a test for equality, `=(10 11)`.

#### Examples

```
> !=(20)
[1 20]

> !=(~zod)
[1 0]

> !=((add 2 2))
[8 [9 3.110.356 0 31] 9 2 [0 4] [7 [0 3] 1 2 2] 0 11]
```

Don't confuse the `!=` rune with:

```
> !=(10 11)
%.y

> !=(10 10)
%.n
```

The syntax difference is that a test for equality takes two subexpressions, and
the `!=` rune only one.

---

## `!?` "zapwut"

Restrict Hoon version.

#### Syntax

Two arguments, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !?  p
  q
  ```

---

- Wide
- ```hoon
  !?(p q)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpwt p=$@(p=@ [p=@ q=@]) q=hoon]
```

#### Produces

When `p` is an atom:

- `q` if `p` ≥ Hoon kelvin version, otherwise crash.

When `p` is a cell:

- `q`, if `p.p` ≥ Hoon kelvin version ≥ `q.p`, otherwise crash.

(Versions count down; the current version is 140.)

#### Examples

```
> !?  [142 140]  (add 2 2)
4

> !?  142  (add 2 2)
4

> !?  64  (add 2 2)
! exit
```

---

## `!@` "zappat"

Branch on whether a wing exists.

#### Syntax

Three arguments, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !@  p
    q
  r
  ```

---

- Wide
- ```hoon
  !@(p q r)
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zppt p=(list wing) q=hoon r=hoon]
```

#### Discussion

`p` is a wing reference like `foo`, `bar.foo`, etc. If `p` exists, `q`. If `p`
does not exist, `r`. Essentially, this is like `?:` for wing existence.

#### Examples

```
> =foo 42

> !@(foo 'exists' 'does not exist')
'exists'

> !@(baz 'exists' 'does not exist')
'does not exist'
```

---

## `!!` "zapzap"

Crash.

#### Syntax

No arguments.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !!
  ```

---

- Wide
- ```
  !!
  ```

---

- Irregular
- None.
{% /table %}

#### AST

```hoon
[%zpzp ~]
```

#### Produces

Nothing. Always crashes, with type `%void`.

#### Discussion

`%void` nests in every other type, so you can stub out anything with `!!`.

#### Examples

```
> !!
dojo: hoon expression failed
```

---

## `!:` "zapcol"

Turn on stack trace.

#### Syntax

One argument, fixed

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !:  p
  ```

---

- Wide
- ```hoon
  !:(p)
  ```

---

- Irregular
- None.
{% /table %}

#### Produces

The product of `p` unless `p` crashes, in which case a stack trace is given.

#### Discussion

`!:` is used to turn on a debugging stack trace option for any code you have in
`p`.

#### Examples

```
> ?:(=(0 1) 123 !!)
dojo: hoon expression failed

> !:  ?:(=(0 1) 123 !!)
/~zod/base/~2022.4.2..08.54.53..07d7:<[1 5].[1 22]>
/~zod/base/~2022.4.2..08.54.53..07d7:<[1 19].[1 21]>
dojo: hoon expression failed
```

---

## `!.` "zapdot"

Turn off stack trace for a subexpression `p`

#### Syntax

One argument, fixed.

{% table %}

- Form
- Syntax

---

- Tall
- ```hoon
  !.  p
  ```

---

- Wide
- ```hoon
  !.(p)
  ```

---

- Irregular
- None.
{% /table %}

#### Produces

The product of `p`. If `p` crashes, no stack trace entries are given for that code.

#### Discussion

`!.` is used to turn off a debugging stack trace option for any code you have in
`p`. This rune can be embedded under a `!:` rune for inner loops of your code
that you don't want or need to trace. This is especially useful if a trace
overflows the stack.

#### Examples

```
> %.(1 |=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a))))))
dojo: hoon expression failed

> !:  %.(1 |=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a))))))
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 5].[1 49]>
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 17].[1 47]>
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 22].[1 46]>
...skipping some lines...
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 22].[1 46]>
/~zod/base/~2022.4.2..08.56.45..5ecc:<[1 33].[1 35]>
dojo: hoon expression failed

> !:  %.(1 !.(|=(a=@ ^-(@ ?:(=(a 10) !! $(a +(a)))))))
/~zod/base/~2022.4.2..08.57.07..d40b:<[1 5].[1 53]>
dojo: hoon expression failed
```

---
